{
    "docs": [
        {
            "location": "/", 
            "text": "Strikt is an assertion library for Kotlin intended for use with a test runner such as \nJUnit\n or \nSpek\n.\nIt's inspired by \nAssertJ\n, \nAtrium\n and \nHamkrest\n.\nHowever, none of those provided exactly what I wanted so I decided to create my own.\n\n\nStrikt gets you\u2026\n\n\nStrong typing\n\n\nAssertion functions can \"narrow\" the type of the assertion:\n\n\nval subject: Any? = \nThe Enlightened take things Lightly\n\nexpect(subject)                // type: Assertion\nAny?\n\n  .isNotNull()                 // type: Assertion\nAny\n\n  .isA\nString\n()               // type: Assertion\nString\n\n  .matches(Regex(\n[\\\\w\\\\s]+\n)) // only available on Assertion\nCharSequence\n\n\n\n\n\nAssertions can \"map\" to properties and method results in a type safe way:\n\n\nval subject = Pantheon.ERIS\nexpect(subject)\n  .map(Deity::realm)  // type safe reference to a property narrows assertion\n  .map { toString() } // narrows assertion to return type of method call\n  .isEqualTo(\ndiscord and confusion\n)\n\n\n\n\nEasy \"soft\" assertions\n\n\nval subject: \nThe Enlightened take things Lightly\n\nexpect(subject) {\n  hasLength(5)          // fails\n  matches(Regex(\n\\d+\n)) // fails\n  startsWith(\nT\n)       // still evaluated and passes\n}\n\n\n\n\nUseful, structured diagnostics\n\n\nMultiple Failures (2 failures)\n    has length 5 : found 35\n    matches the regular expression /\\d+/\n\n\n\n\nExtensibility\n\n\nEasy custom assertions:\n\n\nfun Assertion\nLocalDate\n.isStTibsDay() =\n  assert(\nis St. Tib's Day\n) {\n    when (MonthDay.from(subject)) {\n      MonthDay.of(2, 29) -\n pass()\n      else               -\n fail()\n    }\n  }\n\nexpect(LocalDate.of(2018, 5, 15)).isStTibsDay()\n\n\n\n\nWith the same diagnostic quality:\n\n\nExpect that 2018-05-15 (1 failure)\n    is St. Tib's Day \n\n\n\n\nEasy custom narrowing:\n\n\nval Assertion\nDeity\n.realm: Assertion\nString\n\n  get() = map(Deity::realm)\n\nval subject = Pantheon.ERIS\nexpect(subject).realm.isEqualTo(\ndiscord and confusion\n)\n\n\n\n\nSimple setup\n\n\nOne dependency. Two imports. Go!\n\n\nrepositories { \n  jcenter() \n}\n\ndependencies {\n  testCompile \nio.strikt:strikt-core:0.6.0\n\n}\n\n\n\n\nimport strikt.api.*\nimport strikt.assertions.*\n\n\n\n\nSimple API, complex capabilities\n\n\nval subject = Pantheon.values()\nexpect(subject).any {\n  culture.isEqualTo(\nGr\u0153co-Californian\n)\n  realm.isEqualTo(\ndiscord and confusion\n)\n  aliases.contains(\nDiscordia\n)\n}\n\n\n\n\nDetailed reporting\n\n\n\u25bc Expect that [Eris, Thor]\n  \u2713 at least one element matches:\n    \u25bc Expect that Eris\n      \u25bc .culture \nGr\u0153co-Californian\n\n        \u2713 is equal to \nGr\u0153co-Californian\n\n      \u25bc .realm \ndiscord and confusion\n\n        \u2713 is equal to \ndiscord and confusion\n\n      \u25bc .aliases [\n\u1f1c\u03c1\u03b9\u03c2\n, \nDiscordia\n]\n        \u2713 contains the elements [\nDiscordia\n]\n          \u25bc Expect that [\n\u1f1c\u03c1\u03b9\u03c2\n, \nDiscordia\n]\n            \u2713 contains \nDiscordia\n\n    \u25bc Expect that Thor\n      \u25bc .culture \nNorse\n\n        \u2717 is equal to \nGr\u0153co-Californian\n\n      \u25bc .realm \nthunder\n\n        \u2717 is equal to \ndiscord and confusion\n\n      \u25bc .aliases [\n\u00de\u00f3rr\n, \n\u00deunor\n]\n        \u2717 contains the elements [\nDiscordia\n]\n          \u25bc Expect that [\n\u00de\u00f3rr\n, \n\u00deunor\n]\n            \u2717 contains \nDiscordia", 
            "title": "Home"
        }, 
        {
            "location": "/#strong-typing", 
            "text": "Assertion functions can \"narrow\" the type of the assertion:  val subject: Any? =  The Enlightened take things Lightly \nexpect(subject)                // type: Assertion Any? \n  .isNotNull()                 // type: Assertion Any \n  .isA String ()               // type: Assertion String \n  .matches(Regex( [\\\\w\\\\s]+ )) // only available on Assertion CharSequence   Assertions can \"map\" to properties and method results in a type safe way:  val subject = Pantheon.ERIS\nexpect(subject)\n  .map(Deity::realm)  // type safe reference to a property narrows assertion\n  .map { toString() } // narrows assertion to return type of method call\n  .isEqualTo( discord and confusion )", 
            "title": "Strong typing"
        }, 
        {
            "location": "/#easy-soft-assertions", 
            "text": "val subject:  The Enlightened take things Lightly \nexpect(subject) {\n  hasLength(5)          // fails\n  matches(Regex( \\d+ )) // fails\n  startsWith( T )       // still evaluated and passes\n}", 
            "title": "Easy \"soft\" assertions"
        }, 
        {
            "location": "/#useful-structured-diagnostics", 
            "text": "Multiple Failures (2 failures)\n    has length 5 : found 35\n    matches the regular expression /\\d+/", 
            "title": "Useful, structured diagnostics"
        }, 
        {
            "location": "/#extensibility", 
            "text": "Easy custom assertions:  fun Assertion LocalDate .isStTibsDay() =\n  assert( is St. Tib's Day ) {\n    when (MonthDay.from(subject)) {\n      MonthDay.of(2, 29) -  pass()\n      else               -  fail()\n    }\n  }\n\nexpect(LocalDate.of(2018, 5, 15)).isStTibsDay()  With the same diagnostic quality:  Expect that 2018-05-15 (1 failure)\n    is St. Tib's Day   Easy custom narrowing:  val Assertion Deity .realm: Assertion String \n  get() = map(Deity::realm)\n\nval subject = Pantheon.ERIS\nexpect(subject).realm.isEqualTo( discord and confusion )", 
            "title": "Extensibility"
        }, 
        {
            "location": "/#simple-setup", 
            "text": "One dependency. Two imports. Go!  repositories { \n  jcenter() \n}\n\ndependencies {\n  testCompile  io.strikt:strikt-core:0.6.0 \n}  import strikt.api.*\nimport strikt.assertions.*", 
            "title": "Simple setup"
        }, 
        {
            "location": "/#simple-api-complex-capabilities", 
            "text": "val subject = Pantheon.values()\nexpect(subject).any {\n  culture.isEqualTo( Gr\u0153co-Californian )\n  realm.isEqualTo( discord and confusion )\n  aliases.contains( Discordia )\n}", 
            "title": "Simple API, complex capabilities"
        }, 
        {
            "location": "/#detailed-reporting", 
            "text": "\u25bc Expect that [Eris, Thor]\n  \u2713 at least one element matches:\n    \u25bc Expect that Eris\n      \u25bc .culture  Gr\u0153co-Californian \n        \u2713 is equal to  Gr\u0153co-Californian \n      \u25bc .realm  discord and confusion \n        \u2713 is equal to  discord and confusion \n      \u25bc .aliases [ \u1f1c\u03c1\u03b9\u03c2 ,  Discordia ]\n        \u2713 contains the elements [ Discordia ]\n          \u25bc Expect that [ \u1f1c\u03c1\u03b9\u03c2 ,  Discordia ]\n            \u2713 contains  Discordia \n    \u25bc Expect that Thor\n      \u25bc .culture  Norse \n        \u2717 is equal to  Gr\u0153co-Californian \n      \u25bc .realm  thunder \n        \u2717 is equal to  discord and confusion \n      \u25bc .aliases [ \u00de\u00f3rr ,  \u00deunor ]\n        \u2717 contains the elements [ Discordia ]\n          \u25bc Expect that [ \u00de\u00f3rr ,  \u00deunor ]\n            \u2717 contains  Discordia", 
            "title": "Detailed reporting"
        }, 
        {
            "location": "/user-guide/getting-started/", 
            "text": "Getting Started\n\n\nStrikt does not depend on any particular test runner.\nIt can be used with JUnit, Spek or any other runner that supports tests written in Kotlin.\n\n\nInstallation\n\n\nStrikt is available from JCenter.\nAdd the following to your \nbuild.gradle\n.\n\n\nrepositories { \n  jcenter() \n}\n\ndependencies {\n  testCompile \nio.strikt:strikt-core:0.6.0\n\n}\n\n\n\n\nImporting the Strikt API\n\n\nAdd the following imports to your test:\n\n\nimport strikt.api.*\nimport strikt.assertions.*\n\n\n\n\nThe \nstrikt.api\n package contains top level functions such as \nexpect\n and \nthrows\n that you will use to create assertions as well as the API classes you will interact with if you decide to implement your own assertion functions.\nThe \nstrikt.assertions\n package contains the standard library of assertion functions.", 
            "title": "Getting Started"
        }, 
        {
            "location": "/user-guide/getting-started/#getting-started", 
            "text": "Strikt does not depend on any particular test runner.\nIt can be used with JUnit, Spek or any other runner that supports tests written in Kotlin.", 
            "title": "Getting Started"
        }, 
        {
            "location": "/user-guide/getting-started/#installation", 
            "text": "Strikt is available from JCenter.\nAdd the following to your  build.gradle .  repositories { \n  jcenter() \n}\n\ndependencies {\n  testCompile  io.strikt:strikt-core:0.6.0 \n}", 
            "title": "Installation"
        }, 
        {
            "location": "/user-guide/getting-started/#importing-the-strikt-api", 
            "text": "Add the following imports to your test:  import strikt.api.*\nimport strikt.assertions.*  The  strikt.api  package contains top level functions such as  expect  and  throws  that you will use to create assertions as well as the API classes you will interact with if you decide to implement your own assertion functions.\nThe  strikt.assertions  package contains the standard library of assertion functions.", 
            "title": "Importing the Strikt API"
        }, 
        {
            "location": "/user-guide/assertion-styles/", 
            "text": "Assertion styles\n\n\nTwo different styles of assertion -- chained and block -- are supported for different use-cases.\nYou can mix and match both in the same test and even nest chained assertions inside block assertions.\n\n\nChained assertions\n\n\nChained assertions use a fluent API similar to AssertJ.\nThey fail fast.\nThat is, the first assertion that fails breaks the chain and further assertions are not evaluated.\n\n\nEach assertion in the chain returns an \nAssertion\n object that supports further assertions.\n\n\nval subject = \ncovfefe\n\nexpect(subject)\n  .isA\nString\n()\n  .hasLength(1)\n  .isUpperCase()\n\n\n\n\nProduces the output: \n\n\nExpect that \ncovfefe\n (1 failure)\n    has length 1 : found 7\n\n\n\n\nNotice that the \nisUpperCase()\n assertion is not applied as the earlier \nhasLength(1)\n assertion failed.\n\n\nBlock assertions\n\n\nBlock assertions are declared in a lambda whose receiver is an \nAssertion\nT\n object.\nThey allow multiple assertions (or assertion chains) to be evaluated against the subject.\n\n\nBlock assertions do \nnot\n fail fast.\nThat is, all assertions in the block are evaluated and the result of the \"compound\" assertion will include results for all the assertions made in the block.\n\n\nval subject = \ncovfefe\n\nexpect(subject) {\n  isA\nString\n()\n  hasLength(1)\n  isUpperCase()\n}\n\n\n\n\nProduces the output:\n\n\nExpect that \ncovfefe\n (2 failures)\n    has length 1 : found 7\n    is upper case\n\n\n\n\nAll assertions are applied and since two fail there are two errors logged.\n\n\nChained assertions inside block assertions\n\n\nChained assertions inside a block \nwill\n still fail fast but will not prevent other assertions in the block from being evaluated.\n\n\nval subject = 1L\nexpect(subject) {\n  lessThan(1).isA\nInt\n()\n  greaterThan(1)\n}\n\n\n\n\nProduces the output:\n\n\nExpect that 1\n    is less than 1 : found 1\n    is greater than 1 : found 1\n\n\n\n\nNote the \nisA\nInt\n assertion (that would have failed) was not evaluated since it was chained after \nlessThan(1)\n which failed.\nThe \ngreaterThan(1)\n assertion \nwas\n evaluated since it was not part of the same chain.", 
            "title": "Assertion Styles"
        }, 
        {
            "location": "/user-guide/assertion-styles/#assertion-styles", 
            "text": "Two different styles of assertion -- chained and block -- are supported for different use-cases.\nYou can mix and match both in the same test and even nest chained assertions inside block assertions.", 
            "title": "Assertion styles"
        }, 
        {
            "location": "/user-guide/assertion-styles/#chained-assertions", 
            "text": "Chained assertions use a fluent API similar to AssertJ.\nThey fail fast.\nThat is, the first assertion that fails breaks the chain and further assertions are not evaluated.  Each assertion in the chain returns an  Assertion  object that supports further assertions.  val subject =  covfefe \nexpect(subject)\n  .isA String ()\n  .hasLength(1)\n  .isUpperCase()  Produces the output:   Expect that  covfefe  (1 failure)\n    has length 1 : found 7  Notice that the  isUpperCase()  assertion is not applied as the earlier  hasLength(1)  assertion failed.", 
            "title": "Chained assertions"
        }, 
        {
            "location": "/user-guide/assertion-styles/#block-assertions", 
            "text": "Block assertions are declared in a lambda whose receiver is an  Assertion T  object.\nThey allow multiple assertions (or assertion chains) to be evaluated against the subject.  Block assertions do  not  fail fast.\nThat is, all assertions in the block are evaluated and the result of the \"compound\" assertion will include results for all the assertions made in the block.  val subject =  covfefe \nexpect(subject) {\n  isA String ()\n  hasLength(1)\n  isUpperCase()\n}  Produces the output:  Expect that  covfefe  (2 failures)\n    has length 1 : found 7\n    is upper case  All assertions are applied and since two fail there are two errors logged.", 
            "title": "Block assertions"
        }, 
        {
            "location": "/user-guide/assertion-styles/#chained-assertions-inside-block-assertions", 
            "text": "Chained assertions inside a block  will  still fail fast but will not prevent other assertions in the block from being evaluated.  val subject = 1L\nexpect(subject) {\n  lessThan(1).isA Int ()\n  greaterThan(1)\n}  Produces the output:  Expect that 1\n    is less than 1 : found 1\n    is greater than 1 : found 1  Note the  isA Int  assertion (that would have failed) was not evaluated since it was chained after  lessThan(1)  which failed.\nThe  greaterThan(1)  assertion  was  evaluated since it was not part of the same chain.", 
            "title": "Chained assertions inside block assertions"
        }, 
        {
            "location": "/user-guide/flow-typing/", 
            "text": "Strongly Typed Assertions\n\n\nStrikt's API is designed to work with Kotlin's strong type system. \n\n\nStrikt's assertion API uses the class \nAssertion\nT\n, with the generic type \nT\n representing the (declared) type of the assertion subject.\nAssertion functions such as \nisEqualTo\n are implemented as extension functions on \nAssertion\n with an appropriate generic type.\n\n\nFor example \nisEqualTo\n is an extension function on \nAssertion\nAny?\n as it's useful for many types of subject whereas \nisEqualToIgnoringCase\n is an extension function on \nAssertion\nCharSequence\n since it only makes sense to use it on string-like things. \n\n\nSome assertion functions will return an \nAssertion\n \ndifferent\n, more specific, generic type to the one they were called on.\n\n\nNullable subjects\n\n\nFor example, if the subject of an assertion is a nullable type (in other words it's an \nAssertion\nT?\n) the assertion methods \nisNull()\n and \nisNotNull()\n are available.\nThe return type of \nisNotNull()\n is \nAssertion\nT\n because we now \nknow\n the subject is not null.\nYou will find IDE code-completion will no longer offer the \nisNull()\n and \nisNotNull()\n assertion methods.\n\n\nNarrowing assertions\n\n\nAnother example is making assertions about a subject's specific runtime type, or \"narrowing\".\n\n\nFor example:\n\n\nval subject: Map\nString, Any\n = mapOf(\ncount\n to 1, \nname\n to \nRob\n)\nexpect(subject.get(\ncount\n))\n  .isA\nNumber\n()\n  .isGreaterThan(0)\n\nexpect(subject.get(\nname\n))\n  .isA\nString\n()\n  .hasLength(3)\n\n\n\n\nThe return type of the subject map's \nget()\n method is \nAny\n but using the narrowing assertion \nisA\nT\n()\n we can both assert the type of the value and, because the compiler now knows it is dealing with an \nAssertion\nString\n or an \nAssertion\nNumber\n, we can use more specialized assertion methods that are only available for those subject types.\n\n\nWithout the \nisA\nT\n()\n assertion the code would not compile:\n\n\nval subject: Map\nString, Any\n = mapOf(\ncount\n to 1, \nname\n to \nRob\n)\nexpect(subject.get(\ncount\n))\n  .isGreaterThan(0) \n  // isGreaterThan does not exist on Assertion\nAny\n\n\nexpect(subject.get(\nname\n))\n  .hasLength(3) \n  // hasLength does not exist on Assertion\nAny\n\n\n\n\n\nThis mechanism means that IDE code-completion is optimally helpful as only assertion methods that are appropriate to the subject type will be suggested.", 
            "title": "Strongly-Typed Assertions"
        }, 
        {
            "location": "/user-guide/flow-typing/#strongly-typed-assertions", 
            "text": "Strikt's API is designed to work with Kotlin's strong type system.   Strikt's assertion API uses the class  Assertion T , with the generic type  T  representing the (declared) type of the assertion subject.\nAssertion functions such as  isEqualTo  are implemented as extension functions on  Assertion  with an appropriate generic type.  For example  isEqualTo  is an extension function on  Assertion Any?  as it's useful for many types of subject whereas  isEqualToIgnoringCase  is an extension function on  Assertion CharSequence  since it only makes sense to use it on string-like things.   Some assertion functions will return an  Assertion   different , more specific, generic type to the one they were called on.", 
            "title": "Strongly Typed Assertions"
        }, 
        {
            "location": "/user-guide/flow-typing/#nullable-subjects", 
            "text": "For example, if the subject of an assertion is a nullable type (in other words it's an  Assertion T? ) the assertion methods  isNull()  and  isNotNull()  are available.\nThe return type of  isNotNull()  is  Assertion T  because we now  know  the subject is not null.\nYou will find IDE code-completion will no longer offer the  isNull()  and  isNotNull()  assertion methods.", 
            "title": "Nullable subjects"
        }, 
        {
            "location": "/user-guide/flow-typing/#narrowing-assertions", 
            "text": "Another example is making assertions about a subject's specific runtime type, or \"narrowing\".  For example:  val subject: Map String, Any  = mapOf( count  to 1,  name  to  Rob )\nexpect(subject.get( count ))\n  .isA Number ()\n  .isGreaterThan(0)\n\nexpect(subject.get( name ))\n  .isA String ()\n  .hasLength(3)  The return type of the subject map's  get()  method is  Any  but using the narrowing assertion  isA T ()  we can both assert the type of the value and, because the compiler now knows it is dealing with an  Assertion String  or an  Assertion Number , we can use more specialized assertion methods that are only available for those subject types.  Without the  isA T ()  assertion the code would not compile:  val subject: Map String, Any  = mapOf( count  to 1,  name  to  Rob )\nexpect(subject.get( count ))\n  .isGreaterThan(0) \n  // isGreaterThan does not exist on Assertion Any \n\nexpect(subject.get( name ))\n  .hasLength(3) \n  // hasLength does not exist on Assertion Any   This mechanism means that IDE code-completion is optimally helpful as only assertion methods that are appropriate to the subject type will be suggested.", 
            "title": "Narrowing assertions"
        }, 
        {
            "location": "/user-guide/mapping/", 
            "text": "Mapping Over Assertion Subjects\n\n\nAlthough you can obviously write assertions for the properties of an object with code like this:\n\n\nexpect(map.size).isEqualTo(1)\nexpect(list.first()).isEqualTo(\ncovfefe\n)\nexpect(person.name).isEqualTo(\nZiggy\n)\n\n\n\n\nSometimes it's useful to be able to transform an assertion on a subject to an assertion on a property of that subject, or the result of a method call.\nStrikt allows for this using the \nAssertion\nT\n.map\n method.  \n\n\nMapping with lambdas\n\n\nThe method takes a lambda whose receiver is the current subject and returns an \nAssertion\nR\n where \nR\n is whatever the lambda returns.\n\n\nThis is sometimes useful for making assertions about the properties of an object or the values returned by methods, particularly if you want to use a block-style assertion to validate multiple object properties.\n\n\nval subject = Person(name = \nDavid\n, birthDate = LocalDate.of(1947, 1, 8))\nexpect(subject) {\n  map { name }.isEqualTo(\nDavid\n)\n  map { birthDate }.map { year }.isEqualTo(1947)\n}\n\n\n\n\nMapping with property or method references\n\n\nIf you use a Kotlin property or Java method reference as the lambda passed to \nmap\n, Strikt will automatically derive the property name and use it as the subject description on the returned assertion. \nThis is useful for generating good quality assertion output with minimal effort.\n\n\nFor example, if the previous example fails it will format the error message like this:\n\n\nPerson[name: Ziggy, birthDate: 1972-06-16] (2 failures) \n    Expect that \nZiggy\n (1 failure)\n        is equal to \nDavid\n : found \nZiggy\n\n    Expect that 1972-06-16 (1 failure) \n        Expect that 1972 (1 failure)\n            is equal to 1947 : found 1972\n\n\n\n\nUsing property references the output is more useful.\n\n\nval subject = Person(name = \nDavid\n, birthDate = LocalDate.of(1947, 1, 8))\nexpect(subject) {\n  map(Person::name).isEqualTo(\nDavid\n)\n  map(Person::birthDate).map(LocalDate::getYear).isEqualTo(1947)\n}\n\n\n\n\nPerson[name: Ziggy, birthDate: 1972-06-16] (2 failures) \n    .name \nZiggy\n (1 failure)\n        is equal to \nDavid\n : found \nZiggy\n\n    .birthDate 1972-06-16 (1 failure) \n        .year 1972 (1 failure)\n            is equal to 1947 : found 1972\n\n\n\n\nCreating re-usable mappings with extensions\n\n\nIf you find yourself frequently using \nmap\n for the same properties or methods, you should consider defining extension property or method to make things even easier.\nStrikt makes this easy.\n\n\nFor example:\n\n\nval Assertion\nPerson\n.name: Assertion\nString\n\n  get() = map(Person::name)\n\nval Assertion\nPerson\n.yearOfBirth: Assertion\nLocalDate\n\n  get() = map { dateOfBirth.year }\n\n\n\n\nYou can then write the earlier example as:\n\n\nval subject = Person(name = \nDavid\n, birthDate = LocalDate.of(1947, 1, 8))\nexpect(subject) {\n  name.isEqualTo(\nDavid\n)\n  yearOfBirth.isEqualTo(1947)\n}\n\n\n\n\nBuilt-in mappings\n\n\nStrikt has a number of built in mapping properties and functions such as \nAssertion\nList\nE\n.first()\n which returns an \nAssertion\nE\n whose subject is the first element of the list.", 
            "title": "Mapping Over Assertion Subjects"
        }, 
        {
            "location": "/user-guide/mapping/#mapping-over-assertion-subjects", 
            "text": "Although you can obviously write assertions for the properties of an object with code like this:  expect(map.size).isEqualTo(1)\nexpect(list.first()).isEqualTo( covfefe )\nexpect(person.name).isEqualTo( Ziggy )  Sometimes it's useful to be able to transform an assertion on a subject to an assertion on a property of that subject, or the result of a method call.\nStrikt allows for this using the  Assertion T .map  method.", 
            "title": "Mapping Over Assertion Subjects"
        }, 
        {
            "location": "/user-guide/mapping/#mapping-with-lambdas", 
            "text": "The method takes a lambda whose receiver is the current subject and returns an  Assertion R  where  R  is whatever the lambda returns.  This is sometimes useful for making assertions about the properties of an object or the values returned by methods, particularly if you want to use a block-style assertion to validate multiple object properties.  val subject = Person(name =  David , birthDate = LocalDate.of(1947, 1, 8))\nexpect(subject) {\n  map { name }.isEqualTo( David )\n  map { birthDate }.map { year }.isEqualTo(1947)\n}", 
            "title": "Mapping with lambdas"
        }, 
        {
            "location": "/user-guide/mapping/#mapping-with-property-or-method-references", 
            "text": "If you use a Kotlin property or Java method reference as the lambda passed to  map , Strikt will automatically derive the property name and use it as the subject description on the returned assertion. \nThis is useful for generating good quality assertion output with minimal effort.  For example, if the previous example fails it will format the error message like this:  Person[name: Ziggy, birthDate: 1972-06-16] (2 failures) \n    Expect that  Ziggy  (1 failure)\n        is equal to  David  : found  Ziggy \n    Expect that 1972-06-16 (1 failure) \n        Expect that 1972 (1 failure)\n            is equal to 1947 : found 1972  Using property references the output is more useful.  val subject = Person(name =  David , birthDate = LocalDate.of(1947, 1, 8))\nexpect(subject) {\n  map(Person::name).isEqualTo( David )\n  map(Person::birthDate).map(LocalDate::getYear).isEqualTo(1947)\n}  Person[name: Ziggy, birthDate: 1972-06-16] (2 failures) \n    .name  Ziggy  (1 failure)\n        is equal to  David  : found  Ziggy \n    .birthDate 1972-06-16 (1 failure) \n        .year 1972 (1 failure)\n            is equal to 1947 : found 1972", 
            "title": "Mapping with property or method references"
        }, 
        {
            "location": "/user-guide/mapping/#creating-re-usable-mappings-with-extensions", 
            "text": "If you find yourself frequently using  map  for the same properties or methods, you should consider defining extension property or method to make things even easier.\nStrikt makes this easy.  For example:  val Assertion Person .name: Assertion String \n  get() = map(Person::name)\n\nval Assertion Person .yearOfBirth: Assertion LocalDate \n  get() = map { dateOfBirth.year }  You can then write the earlier example as:  val subject = Person(name =  David , birthDate = LocalDate.of(1947, 1, 8))\nexpect(subject) {\n  name.isEqualTo( David )\n  yearOfBirth.isEqualTo(1947)\n}", 
            "title": "Creating re-usable mappings with extensions"
        }, 
        {
            "location": "/user-guide/mapping/#built-in-mappings", 
            "text": "Strikt has a number of built in mapping properties and functions such as  Assertion List E .first()  which returns an  Assertion E  whose subject is the first element of the list.", 
            "title": "Built-in mappings"
        }, 
        {
            "location": "/user-guide/common-patterns/", 
            "text": "Common Assertion Patterns\n\n\nThis section contains some common uses of Strikt's standard assertion library.\n\n\nAssertions on elements of a collection\n\n\nSome assertions on collections include sub-assertions applied to the elements of the collection.\nFor example, we can assert that \nall\n elements conform to a repeated assertion.\n\n\nval subject = setOf(\ncatflap\n, \nrubberplant\n, \nmarzipan\n)\nexpect(subject).all {\n  isLowerCase()\n  startsWith('c')\n}\n\n\n\n\nThis produces the output:\n\n\nExpect that [catflap, rubberplant, marzipan] (1 failure)\n    all elements match: (2 failures)\n        Expect that \nrubberplant\n (1 failure)\n            starts with 'c'\n        Expect that \nmarzipan\n (1 failure)\n            starts with 'c'\n\n\n\n\nThe results are broken down by individual elements in the collection so it's easy to see which failed.\n\n\nAsserting exceptions are thrown\n\n\nTo assert that some code throws an exception you can use an assertion on a lambda \n() -\n Unit\n that performs the operation that should throw an exception and the \nthrows\nE\n assertion function.\nFor example:\n\n\nexpect { service.computeMeaning() }\n  .throws\nTooMuchFlaxException\n()\n\n\n\n\nThe \nthrows\nE\n function returns an \nAssertion\nE\n so you can chain assertions about the exception after it.\n\n\nThere is also a top level function \nthrows( () -\n Unit )\n that makes this even more concise.\n\n\nthrows\nTooMuchFlaxException\n { \n  service.computeMeaning() \n}", 
            "title": "Common Assertion Patterns"
        }, 
        {
            "location": "/user-guide/common-patterns/#common-assertion-patterns", 
            "text": "This section contains some common uses of Strikt's standard assertion library.", 
            "title": "Common Assertion Patterns"
        }, 
        {
            "location": "/user-guide/common-patterns/#assertions-on-elements-of-a-collection", 
            "text": "Some assertions on collections include sub-assertions applied to the elements of the collection.\nFor example, we can assert that  all  elements conform to a repeated assertion.  val subject = setOf( catflap ,  rubberplant ,  marzipan )\nexpect(subject).all {\n  isLowerCase()\n  startsWith('c')\n}  This produces the output:  Expect that [catflap, rubberplant, marzipan] (1 failure)\n    all elements match: (2 failures)\n        Expect that  rubberplant  (1 failure)\n            starts with 'c'\n        Expect that  marzipan  (1 failure)\n            starts with 'c'  The results are broken down by individual elements in the collection so it's easy to see which failed.", 
            "title": "Assertions on elements of a collection"
        }, 
        {
            "location": "/user-guide/common-patterns/#asserting-exceptions-are-thrown", 
            "text": "To assert that some code throws an exception you can use an assertion on a lambda  () -  Unit  that performs the operation that should throw an exception and the  throws E  assertion function.\nFor example:  expect { service.computeMeaning() }\n  .throws TooMuchFlaxException ()  The  throws E  function returns an  Assertion E  so you can chain assertions about the exception after it.  There is also a top level function  throws( () -  Unit )  that makes this even more concise.  throws TooMuchFlaxException  { \n  service.computeMeaning() \n}", 
            "title": "Asserting exceptions are thrown"
        }, 
        {
            "location": "/user-guide/custom-assertions/", 
            "text": "Custom Assertions\n\n\nOne of the aims of Strikt is that implementing your own assertions is \nreally, really\n easy.\nAssertion functions are \nextension functions\n on the interface \nAssertion\nT\n.\n\n\nAtomic assertions\n\n\n\"Atomic\" assertions produce a single message on failure.\nThey call \nassert\n passing a lambda with the assertion logic that calls \npass()\n or \nfail()\n.\n\n\nThe standard assertions \nisNull\n, \nisEqualTo\n, \nisA\nT\n and many others are simple assertions implemented just like this.\n\n\nLet's imagine we're implementing an assertion function for \njava.time.LocalDate\n that tests if the represented date is a leap day.\n\n\nfun Assertion\nLocalDate\n.isStTibsDay(): Assertion\nLocalDate\n =\n  assert(\nis St. Tib's Day\n) { \n    when (MonthDay.from(subject)) {\n      MonthDay.of(2, 29) -\n pass()\n      else               -\n fail()\n    }\n  }\n\n\n\n\nBreaking this down: \n\n\n\n\nWe declare the assertion function applies only to \nAssertion\nLocalDate\n.\n\n\nNote that the function also returns \nAssertion\nLocalDate\n so we can include this assertion as part of a chain.\n\n\nWe call \nassert\n passing a description of the assertion and a lambda with the assertion logic.\n\n\nIf \nsubject\n is the value we want we call \npass()\n otherwise we call \nfail()\n\n\n\n\nIf this assertion fails it will produce a message like:\n\n\nExpect that 2018-05-01 (1 failure)\n    is St. Tib's Day \n\n\n\n\n\n\nInfo\n\n\nThe method \nassert\n accepts a description for the assertion being made and a lambda function \nAssertionContext\nT\n.() -\n Unit\n.\nThat \nAssertionContext\nT\n receiver provides the lambda everything it needs to access the \nsubject\n of the assertion and report the result via the \npass()\n or \nfail()\n method.\n\n\n\n\nDescribing the \"actual\" value\n\n\nFor assertions that perform a comparison between actual and expected values it is usually helpful to describe the value that was incorrect.\nThat way any assertion failure message will be more helpful.\n\n\nIn order to do this, Strikt provides an overridden version of \nfail()\n that accepts a message string and the actual value found.\nThe message string should contain a format placeholder for the value.\n\n\nfun Assertion\nLocalDate\n.isStTibsDay(): Assertion\nLocalDate\n =\n  assert(\nis St. Tib's Day\n) { \n    when (MonthDay.from(subject)) {\n      MonthDay.of(2, 29) -\n pass()\n      else               -\n fail(\n        message = \nin fact it is %s\n, \n        actual = subject\n      )\n    }\n  }\n\n\n\n\nNow if the assertion fails there is a little more detail.\n\n\nExpect that 2018-05-01\n    is St. Tib's Day : in fact it is 2018-05-01\n\n\n\n\nIn this case that's not terribly helpful but when dealing with properties, method return values, or the like it can save a lot of effort in identifying the precise cause of an error.\n\n\nSimple atomic assertions with boolean expressions\n\n\nFor the simplest assertion functions, instead of using \nassert\n and calling \npass\n or \nfail\n, you can use \npassesIf\n with a lambda whose receiver is the assertion subject that returns a boolean.\n\n\nWe can re-implement the example above like this:\n\n\nfun Assertion\nLocalDate\n.isStTibsDay(): Assertion\nLocalDate\n =\n  passesIf(\nis St. Tib's Day\n) { \n    MonthDay.from(this) == MonthDay.of(2, 29)\n  }\n\n\n\n\nYou should not use this form when you want to provide a meaningful description of the actual value but for simple assertions it's slightly less verbose.\n\n\nComposed assertions\n\n\nFor more complex assertion implementations you can \"nest\" sub-assertions inside your overall assertion.\nComposed assertions' results are reported under the overall result which is useful for providing detailed diagnostic information in case of a failure.\n\n\nComposed assertions are useful for things like:\n\n\n\n\napplying assertions to multiple properties of an object, for example for a field-by-field comparison.\n\n\napplying assertions to all elements of a collection or entries in a map, reporting on individual elements.\n\n\n\n\nImagine we're creating an assertion function that tests fails if any element of a collection is \nnull\n.\n\n\nfun \nT: Iterable\nE?\n, E\n Assertion\nT\n.containsNoNullElements(): Assertion\nT\n =\n  compose(\ndoes not contain any null elements\n) {\n    subject.forEach {\n      expect(it).isNotNull()\n    }\n  } then {\n    if (allPassed) pass() else fail()\n  }\n\n\n\n\nBreaking this down:\n\n\n\n\nWe declare the overall assertion function applies to an \nIterable\n of a nullable element type \nE\n.\n\n\nWe use the \ncompose\n method instead of \nassert\n.\n\n\nInside the \ncompose\n block we make assertions about each element of the iterable subject.\n\n\nInside the \nthen\n block we pass or fail the overall assertion depending on whether the nested assertions all passed.\n\n\n\n\nThe receiver of the block passed to \nresult\n has the properties \nallFailed\n, \nanyFailed\n, \nallPassed\n and \nanyPassed\n along with \npass()\n and \nfail()\n functions similar to those used in simple assertions.\n\n\nIf the assertion failed we'll see something like this:\n\n\nExpect that [catflap, null, rubberplant, marzipan] (1 failure) \n    does not contain any null elements (1 failure)\n        Expect that null (1 failure) \n            is not null  \n\n\n\n\nAs well as the overall assertion failure message we get a detailed breakdown allowing us to easily find exactly where the problem is.\n\n\nSeveral assertion functions in Strikt's standard assertions library use nested assertions.\nFor example, \nAssertion\nIterable\nE\n.all\n applies assertions to each element of an \nIterable\n then passes the overall assertion if (and only if) all those nested assertions passed (\nallPassed\n).\nOn the other hand \nAssertion\nIterable\nE\n.any\n applies assertions to the elements of an \nIterable\n but will pass the overall assertion if at least one of those nested assertions passed (\nanyPassed\n).\nThe \nAssertion\nIterable\nE\n.none\n assertion passes only if \nallFailed\n is true for its nested assertions!", 
            "title": "Custom Assertions"
        }, 
        {
            "location": "/user-guide/custom-assertions/#custom-assertions", 
            "text": "One of the aims of Strikt is that implementing your own assertions is  really, really  easy.\nAssertion functions are  extension functions  on the interface  Assertion T .", 
            "title": "Custom Assertions"
        }, 
        {
            "location": "/user-guide/custom-assertions/#atomic-assertions", 
            "text": "\"Atomic\" assertions produce a single message on failure.\nThey call  assert  passing a lambda with the assertion logic that calls  pass()  or  fail() .  The standard assertions  isNull ,  isEqualTo ,  isA T  and many others are simple assertions implemented just like this.  Let's imagine we're implementing an assertion function for  java.time.LocalDate  that tests if the represented date is a leap day.  fun Assertion LocalDate .isStTibsDay(): Assertion LocalDate  =\n  assert( is St. Tib's Day ) { \n    when (MonthDay.from(subject)) {\n      MonthDay.of(2, 29) -  pass()\n      else               -  fail()\n    }\n  }  Breaking this down:    We declare the assertion function applies only to  Assertion LocalDate .  Note that the function also returns  Assertion LocalDate  so we can include this assertion as part of a chain.  We call  assert  passing a description of the assertion and a lambda with the assertion logic.  If  subject  is the value we want we call  pass()  otherwise we call  fail()   If this assertion fails it will produce a message like:  Expect that 2018-05-01 (1 failure)\n    is St. Tib's Day    Info  The method  assert  accepts a description for the assertion being made and a lambda function  AssertionContext T .() -  Unit .\nThat  AssertionContext T  receiver provides the lambda everything it needs to access the  subject  of the assertion and report the result via the  pass()  or  fail()  method.", 
            "title": "Atomic assertions"
        }, 
        {
            "location": "/user-guide/custom-assertions/#describing-the-actual-value", 
            "text": "For assertions that perform a comparison between actual and expected values it is usually helpful to describe the value that was incorrect.\nThat way any assertion failure message will be more helpful.  In order to do this, Strikt provides an overridden version of  fail()  that accepts a message string and the actual value found.\nThe message string should contain a format placeholder for the value.  fun Assertion LocalDate .isStTibsDay(): Assertion LocalDate  =\n  assert( is St. Tib's Day ) { \n    when (MonthDay.from(subject)) {\n      MonthDay.of(2, 29) -  pass()\n      else               -  fail(\n        message =  in fact it is %s , \n        actual = subject\n      )\n    }\n  }  Now if the assertion fails there is a little more detail.  Expect that 2018-05-01\n    is St. Tib's Day : in fact it is 2018-05-01  In this case that's not terribly helpful but when dealing with properties, method return values, or the like it can save a lot of effort in identifying the precise cause of an error.", 
            "title": "Describing the \"actual\" value"
        }, 
        {
            "location": "/user-guide/custom-assertions/#simple-atomic-assertions-with-boolean-expressions", 
            "text": "For the simplest assertion functions, instead of using  assert  and calling  pass  or  fail , you can use  passesIf  with a lambda whose receiver is the assertion subject that returns a boolean.  We can re-implement the example above like this:  fun Assertion LocalDate .isStTibsDay(): Assertion LocalDate  =\n  passesIf( is St. Tib's Day ) { \n    MonthDay.from(this) == MonthDay.of(2, 29)\n  }  You should not use this form when you want to provide a meaningful description of the actual value but for simple assertions it's slightly less verbose.", 
            "title": "Simple atomic assertions with boolean expressions"
        }, 
        {
            "location": "/user-guide/custom-assertions/#composed-assertions", 
            "text": "For more complex assertion implementations you can \"nest\" sub-assertions inside your overall assertion.\nComposed assertions' results are reported under the overall result which is useful for providing detailed diagnostic information in case of a failure.  Composed assertions are useful for things like:   applying assertions to multiple properties of an object, for example for a field-by-field comparison.  applying assertions to all elements of a collection or entries in a map, reporting on individual elements.   Imagine we're creating an assertion function that tests fails if any element of a collection is  null .  fun  T: Iterable E? , E  Assertion T .containsNoNullElements(): Assertion T  =\n  compose( does not contain any null elements ) {\n    subject.forEach {\n      expect(it).isNotNull()\n    }\n  } then {\n    if (allPassed) pass() else fail()\n  }  Breaking this down:   We declare the overall assertion function applies to an  Iterable  of a nullable element type  E .  We use the  compose  method instead of  assert .  Inside the  compose  block we make assertions about each element of the iterable subject.  Inside the  then  block we pass or fail the overall assertion depending on whether the nested assertions all passed.   The receiver of the block passed to  result  has the properties  allFailed ,  anyFailed ,  allPassed  and  anyPassed  along with  pass()  and  fail()  functions similar to those used in simple assertions.  If the assertion failed we'll see something like this:  Expect that [catflap, null, rubberplant, marzipan] (1 failure) \n    does not contain any null elements (1 failure)\n        Expect that null (1 failure) \n            is not null    As well as the overall assertion failure message we get a detailed breakdown allowing us to easily find exactly where the problem is.  Several assertion functions in Strikt's standard assertions library use nested assertions.\nFor example,  Assertion Iterable E .all  applies assertions to each element of an  Iterable  then passes the overall assertion if (and only if) all those nested assertions passed ( allPassed ).\nOn the other hand  Assertion Iterable E .any  applies assertions to the elements of an  Iterable  but will pass the overall assertion if at least one of those nested assertions passed ( anyPassed ).\nThe  Assertion Iterable E .none  assertion passes only if  allFailed  is true for its nested assertions!", 
            "title": "Composed assertions"
        }, 
        {
            "location": "/about/", 
            "text": "About Strikt\n\n\nStrikt was written by \nRob Fletcher\n.\n\n\nLicense\n\n\nStrikt is licensed under the \nApache License v2.0\n.\n\n\nContributing\n\n\nSuggestions and contributions are welcome.\n\n\n\n\nIssues\n: You can discuss and raise issues on \nGitHub\n.\n\n\nSlack\n: Join the \n#strikt\n channel on the Kotlin Slack.\n\n\nTwitter\n: Follow \n@stri_kt\n on Twitter for updates and release notifications.", 
            "title": "About"
        }, 
        {
            "location": "/about/#about-strikt", 
            "text": "Strikt was written by  Rob Fletcher .", 
            "title": "About Strikt"
        }, 
        {
            "location": "/about/#license", 
            "text": "Strikt is licensed under the  Apache License v2.0 .", 
            "title": "License"
        }, 
        {
            "location": "/about/#contributing", 
            "text": "Suggestions and contributions are welcome.   Issues : You can discuss and raise issues on  GitHub .  Slack : Join the  #strikt  channel on the Kotlin Slack.  Twitter : Follow  @stri_kt  on Twitter for updates and release notifications.", 
            "title": "Contributing"
        }
    ]
}