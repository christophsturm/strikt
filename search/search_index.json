{
    "docs": [
        {
            "location": "/", 
            "text": "Strikt is an assertion library for Kotlin intended for use with a test runner such as \nJUnit\n or \nSpek\n.\nIt's inspired by \nAssertJ\n, \nAtrium\n and \nHamkrest\n.\nHowever, none of those provided exactly what I wanted so I decided to create my own.\n\n\nStrikt gets you\u2026\n\n\nStrong typing\n\n\nAssertion functions can \"narrow\" the type of the assertion:\n\n\nval subject: Any? = \nThe Enlightened take things Lightly\n\nexpect(subject)              // type: Assertion\nAny?\n\n  .isNotNull()               // type: Assertion\nAny\n\n  .isA\nString\n()             // type: Assertion\nString\n\n  .matches(Regex(\n[\\w\\s]+\n)) // only available on Assertion\nCharSequence\n\n\n\n\n\nAssertions can \"map\" to properties and method results in a type safe way:\n\n\nval subject = Pantheon.ERIS\nexpect(subject)\n  .map(Deity::realm)  // type safe reference to a property narrows assertion\n  .map { toString() } // narrows assertion to return type of method call\n  .isEqualTo(\ndiscord and confusion\n)\n\n\n\n\nEasy \"soft\" assertions\n\n\nval subject: \nThe Enlightened take things Lightly\n\nexpect(subject) {\n  hasLength(5)          // fails\n  matches(Regex(\n\\d+\n)) // fails\n  startsWith(\nT\n)       // still evaluated and passes\n}\n\n\n\n\nUseful, structured diagnostics\n\n\nAssertion failed:\n\u25bc Expect that \nThe Enlightened take things Lightly\n\n  \u2717 has length 5\n    \u2022 found 35\n  \u2717 matches /\\d+/\n  \u2713 starts with \nT\n\n\n\n\n\nExtensibility\n\n\nEasy custom assertions:\n\n\nfun Assertion\nLocalDate\n.isStTibsDay() =\n  assert(\nis St. Tib's Day\n) { \n    when (MonthDay.from(subject)) {\n      MonthDay.of(2, 29) -\n pass()\n      else               -\n fail()\n    }\n  }\n\nexpect(LocalDate.of(\n2018-05-15\n)).isStTibsDay()\n\n\n\n\nWith the same diagnostic quality:\n\n\n\u25bc Expect that 2018-05-16\n  \u2717 is St. Tib's Day \n\n\n\n\nEasy custom narrowing:\n\n\nval Assertion\nDeity\n.realm: String = map(Deity::realm)\n\nval subject = Pantheon.ERIS\nexpect(subject).realm.isEqualTo(\ndiscord and confusion\n)\n\n\n\n\nSimple setup\n\n\nOne dependency. Two imports. Go!\n\n\nrepositories { \n  jcenter() \n}\n\ndependencies {\n  testCompile \nio.strikt:strikt-core:0.5.1\n\n}\n\n\n\n\nimport strikt.api.*\nimport strikt.assertions.*\n\n\n\n\nSimple API, complex capabilities\n\n\nval subject = Pantheon.values()\nexpect(subject).any {\n  culture.isEqualTo(\nGr\u0153co-Californian\n)\n  realm.isEqualTo(\ndiscord and confusion\n)\n  aliases.contains(\nDiscordia\n)\n}\n\n\n\n\n\u25bc Expect that the pantheon\n  \u2713 at least one element matches:\n    \u25bc Expect that Thor\n      \u2717 .culture is equal to \nGr\u0153co-Californian\n\n        \u2022 found \nNorse\n\n      \u2717 .realm is equal to \ndiscord and confusion\n\n        \u2022 found \nthunder\n\n      \u2717 .aliases contains \nDiscordia\n\n        \u2022 found \n\u00de\u00f3rr\n, \n\u00deunor\n\n    \u25bc Expect that Eris\n      \u2713 .culture is equal to \nGr\u0153co-Californian\n\n      \u2713 .realm is equal to \ndiscord and confusion\n\n      \u2713 .aliases contains \nDiscordia", 
            "title": "Home"
        }, 
        {
            "location": "/#strong-typing", 
            "text": "Assertion functions can \"narrow\" the type of the assertion:  val subject: Any? =  The Enlightened take things Lightly \nexpect(subject)              // type: Assertion Any? \n  .isNotNull()               // type: Assertion Any \n  .isA String ()             // type: Assertion String \n  .matches(Regex( [\\w\\s]+ )) // only available on Assertion CharSequence   Assertions can \"map\" to properties and method results in a type safe way:  val subject = Pantheon.ERIS\nexpect(subject)\n  .map(Deity::realm)  // type safe reference to a property narrows assertion\n  .map { toString() } // narrows assertion to return type of method call\n  .isEqualTo( discord and confusion )", 
            "title": "Strong typing"
        }, 
        {
            "location": "/#easy-soft-assertions", 
            "text": "val subject:  The Enlightened take things Lightly \nexpect(subject) {\n  hasLength(5)          // fails\n  matches(Regex( \\d+ )) // fails\n  startsWith( T )       // still evaluated and passes\n}", 
            "title": "Easy \"soft\" assertions"
        }, 
        {
            "location": "/#useful-structured-diagnostics", 
            "text": "Assertion failed:\n\u25bc Expect that  The Enlightened take things Lightly \n  \u2717 has length 5\n    \u2022 found 35\n  \u2717 matches /\\d+/\n  \u2713 starts with  T", 
            "title": "Useful, structured diagnostics"
        }, 
        {
            "location": "/#extensibility", 
            "text": "Easy custom assertions:  fun Assertion LocalDate .isStTibsDay() =\n  assert( is St. Tib's Day ) { \n    when (MonthDay.from(subject)) {\n      MonthDay.of(2, 29) -  pass()\n      else               -  fail()\n    }\n  }\n\nexpect(LocalDate.of( 2018-05-15 )).isStTibsDay()  With the same diagnostic quality:  \u25bc Expect that 2018-05-16\n  \u2717 is St. Tib's Day   Easy custom narrowing:  val Assertion Deity .realm: String = map(Deity::realm)\n\nval subject = Pantheon.ERIS\nexpect(subject).realm.isEqualTo( discord and confusion )", 
            "title": "Extensibility"
        }, 
        {
            "location": "/#simple-setup", 
            "text": "One dependency. Two imports. Go!  repositories { \n  jcenter() \n}\n\ndependencies {\n  testCompile  io.strikt:strikt-core:0.5.1 \n}  import strikt.api.*\nimport strikt.assertions.*", 
            "title": "Simple setup"
        }, 
        {
            "location": "/#simple-api-complex-capabilities", 
            "text": "val subject = Pantheon.values()\nexpect(subject).any {\n  culture.isEqualTo( Gr\u0153co-Californian )\n  realm.isEqualTo( discord and confusion )\n  aliases.contains( Discordia )\n}  \u25bc Expect that the pantheon\n  \u2713 at least one element matches:\n    \u25bc Expect that Thor\n      \u2717 .culture is equal to  Gr\u0153co-Californian \n        \u2022 found  Norse \n      \u2717 .realm is equal to  discord and confusion \n        \u2022 found  thunder \n      \u2717 .aliases contains  Discordia \n        \u2022 found  \u00de\u00f3rr ,  \u00deunor \n    \u25bc Expect that Eris\n      \u2713 .culture is equal to  Gr\u0153co-Californian \n      \u2713 .realm is equal to  discord and confusion \n      \u2713 .aliases contains  Discordia", 
            "title": "Simple API, complex capabilities"
        }, 
        {
            "location": "/user-guide/getting-started/", 
            "text": "Getting Started\n\n\nStrikt does not depend on any particular test runner.\nIt can be used with JUnit, Spek or any other runner that supports tests written in Kotlin.\n\n\nInstallation\n\n\nStrikt is available from JCenter.\nAdd the following to your \nbuild.gradle\n.\n\n\nrepositories { \n  jcenter() \n}\n\ndependencies {\n  testCompile \nio.strikt:strikt-core:0.5.1\n\n}\n\n\n\n\nImporting the Strikt API\n\n\nAdd the following imports to your test:\n\n\nimport strikt.api.*\nimport strikt.assertions.*\n\n\n\n\nThe \nstrikt.api\n package contains top level functions such as \nexpect\n and \nthrows\n that you will use to create assertions as well as the API classes you will interact with if you decide to implement your own assertion functions.\nThe \nstrikt.assertions\n package contains the standard library of assertion functions.", 
            "title": "Getting Started"
        }, 
        {
            "location": "/user-guide/getting-started/#getting-started", 
            "text": "Strikt does not depend on any particular test runner.\nIt can be used with JUnit, Spek or any other runner that supports tests written in Kotlin.", 
            "title": "Getting Started"
        }, 
        {
            "location": "/user-guide/getting-started/#installation", 
            "text": "Strikt is available from JCenter.\nAdd the following to your  build.gradle .  repositories { \n  jcenter() \n}\n\ndependencies {\n  testCompile  io.strikt:strikt-core:0.5.1 \n}", 
            "title": "Installation"
        }, 
        {
            "location": "/user-guide/getting-started/#importing-the-strikt-api", 
            "text": "Add the following imports to your test:  import strikt.api.*\nimport strikt.assertions.*  The  strikt.api  package contains top level functions such as  expect  and  throws  that you will use to create assertions as well as the API classes you will interact with if you decide to implement your own assertion functions.\nThe  strikt.assertions  package contains the standard library of assertion functions.", 
            "title": "Importing the Strikt API"
        }, 
        {
            "location": "/user-guide/assertion-styles/", 
            "text": "Assertion styles\n\n\nTwo different styles of assertion -- chained and block -- are supported for different use-cases.\nYou can mix and match both in the same test and even nest chained assertions inside block assertions.\n\n\nChained assertions\n\n\nChained assertions use a fluent API similar to AssertJ.\nThey fail fast.\nThat is, the first assertion that fails breaks the chain and further assertions are not evaluated.\n\n\nEach assertion in the chain returns an \nAssertion\n object that supports further assertions.\n\n\nval subject = \ncovfefe\n\nexpect(subject)\n  .isA\nString\n()\n  .hasLength(1)\n  .isUpperCase()\n\n\n\n\nProduces the output: \n\n\n\u25bc Expect that \ncovfefe\n\n  \u2713 is a java.lang.String\n  \u2717 has length 1\n    \u2022 found 7\n\n\n\n\nNotice that the \nisUpperCase()\n assertion is not applied as the earlier \nhasLength(1)\n assertion failed.\n\n\nBlock assertions\n\n\nBlock assertions are declared in a lambda whose receiver is an \nAssertion\nT\n object.\nThey allow multiple assertions (or assertion chains) to be evaluated against the subject.\n\n\nBlock assertions do \nnot\n fail fast.\nThat is, all assertions in the block are evaluated and the result of the \"compound\" assertion will include results for all the assertions made in the block.\n\n\nval subject = \ncovfefe\n\nexpect(subject) {\n  isA\nString\n()\n  hasLength(1)\n  isUpperCase()\n}\n\n\n\n\nProduces the output:\n\n\n\u25bc Expect that \ncovfefe\n\n  \u2713 is a java.lang.String\n  \u2717 has length 1\n    \u2022 found 7\n  \u2717 is upper case\n\n\n\n\nAll assertions are applied and since two fail there are two errors logged.\n\n\nChained assertions inside block assertions\n\n\nChained assertions inside a block \nwill\n still fail fast but will not prevent other assertions in the block from being evaluated.\n\n\nval subject = 1L\nexpect(subject) {\n  lessThan(1).isA\nInt\n()\n  greaterThan(1)\n}\n\n\n\n\nProduces the output:\n\n\n\u25bc Expect that 1\n  \u2717 is less than 1\n  \u2717 is greater than 1\n\n\n\n\nNote the \nisA\nInt\n assertion (that would have failed) was not evaluated since it was chained after \nlessThan(1)\n which failed.\nThe \ngreaterThan(1)\n assertion \nwas\n evaluated since it was not part of the same chain.", 
            "title": "Assertion Styles"
        }, 
        {
            "location": "/user-guide/assertion-styles/#assertion-styles", 
            "text": "Two different styles of assertion -- chained and block -- are supported for different use-cases.\nYou can mix and match both in the same test and even nest chained assertions inside block assertions.", 
            "title": "Assertion styles"
        }, 
        {
            "location": "/user-guide/assertion-styles/#chained-assertions", 
            "text": "Chained assertions use a fluent API similar to AssertJ.\nThey fail fast.\nThat is, the first assertion that fails breaks the chain and further assertions are not evaluated.  Each assertion in the chain returns an  Assertion  object that supports further assertions.  val subject =  covfefe \nexpect(subject)\n  .isA String ()\n  .hasLength(1)\n  .isUpperCase()  Produces the output:   \u25bc Expect that  covfefe \n  \u2713 is a java.lang.String\n  \u2717 has length 1\n    \u2022 found 7  Notice that the  isUpperCase()  assertion is not applied as the earlier  hasLength(1)  assertion failed.", 
            "title": "Chained assertions"
        }, 
        {
            "location": "/user-guide/assertion-styles/#block-assertions", 
            "text": "Block assertions are declared in a lambda whose receiver is an  Assertion T  object.\nThey allow multiple assertions (or assertion chains) to be evaluated against the subject.  Block assertions do  not  fail fast.\nThat is, all assertions in the block are evaluated and the result of the \"compound\" assertion will include results for all the assertions made in the block.  val subject =  covfefe \nexpect(subject) {\n  isA String ()\n  hasLength(1)\n  isUpperCase()\n}  Produces the output:  \u25bc Expect that  covfefe \n  \u2713 is a java.lang.String\n  \u2717 has length 1\n    \u2022 found 7\n  \u2717 is upper case  All assertions are applied and since two fail there are two errors logged.", 
            "title": "Block assertions"
        }, 
        {
            "location": "/user-guide/assertion-styles/#chained-assertions-inside-block-assertions", 
            "text": "Chained assertions inside a block  will  still fail fast but will not prevent other assertions in the block from being evaluated.  val subject = 1L\nexpect(subject) {\n  lessThan(1).isA Int ()\n  greaterThan(1)\n}  Produces the output:  \u25bc Expect that 1\n  \u2717 is less than 1\n  \u2717 is greater than 1  Note the  isA Int  assertion (that would have failed) was not evaluated since it was chained after  lessThan(1)  which failed.\nThe  greaterThan(1)  assertion  was  evaluated since it was not part of the same chain.", 
            "title": "Chained assertions inside block assertions"
        }, 
        {
            "location": "/user-guide/flow-typing/", 
            "text": "Strongly Typed Assertions\n\n\nStrikt's API is designed to work with Kotlin's strong type system. \n\n\nStrikt's assertion API uses the class \nAssertion\nT\n, with the generic type \nT\n representing the (declared) type of the assertion subject.\nAssertion functions such as \nisEqualTo\n are implemented as extension functions on \nAssertion\n with an appropriate generic type.\n\n\nFor example \nisEqualTo\n is an extension function on \nAssertion\nAny?\n as it's useful for many types of subject whereas \nisEqualToIgnoringCase\n is an extension function on \nAssertion\nCharSequence\n since it only makes sense to use it on string-like things. \n\n\nSome assertion functions will return an \nAssertion\n \ndifferent\n, more specific, generic type to the one they were called on.\n\n\nNullable subjects\n\n\nFor example, if the subject of an assertion is a nullable type (in other words it's an \nAssertion\nT?\n) the assertion methods \nisNull()\n and \nisNotNull()\n are available.\nThe return type of \nisNotNull()\n is \nAssertion\nT\n because we now \nknow\n the subject is not null.\nYou will find IDE code-completion will no longer offer the \nisNull()\n and \nisNotNull()\n assertion methods.\n\n\nNarrowing assertions\n\n\nAnother example is making assertions about a subject's specific runtime type, or \"narrowing\".\n\n\nFor example:\n\n\nval subject: Map\nString, Any\n = mapOf(\ncount\n to 1, \nname\n to \nRob\n)\nexpect(subject.get(\ncount\n))\n  .isA\nNumber\n()\n  .isGreaterThan(0)\n\nexpect(subject.get(\nname\n))\n  .isA\nString\n()\n  .hasLength(3)\n\n\n\n\nThe return type of the subject map's \nget()\n method is \nAny\n but using the narrowing assertion \nisA\nT\n()\n we can both assert the type of the value and, because the compiler now knows it is dealing with an \nAssertion\nString\n or an \nAssertion\nNumber\n, we can use more specialized assertion methods that are only available for those subject types.\n\n\nWithout the \nisA\nT\n()\n assertion the code would not compile:\n\n\nval subject: Map\nString, Any\n = mapOf(\ncount\n to 1, \nname\n to \nRob\n)\nexpect(subject.get(\ncount\n))\n  .isGreaterThan(0) \n  // isGreaterThan does not exist on Assertion\nAny\n\n\nexpect(subject.get(\nname\n))\n  .hasLength(3) \n  // hasLength does not exist on Assertion\nAny\n\n\n\n\n\nThis mechanism means that IDE code-completion is optimally helpful as only assertion methods that are appropriate to the subject type will be suggested.", 
            "title": "Strongly-Typed Assertions"
        }, 
        {
            "location": "/user-guide/flow-typing/#strongly-typed-assertions", 
            "text": "Strikt's API is designed to work with Kotlin's strong type system.   Strikt's assertion API uses the class  Assertion T , with the generic type  T  representing the (declared) type of the assertion subject.\nAssertion functions such as  isEqualTo  are implemented as extension functions on  Assertion  with an appropriate generic type.  For example  isEqualTo  is an extension function on  Assertion Any?  as it's useful for many types of subject whereas  isEqualToIgnoringCase  is an extension function on  Assertion CharSequence  since it only makes sense to use it on string-like things.   Some assertion functions will return an  Assertion   different , more specific, generic type to the one they were called on.", 
            "title": "Strongly Typed Assertions"
        }, 
        {
            "location": "/user-guide/flow-typing/#nullable-subjects", 
            "text": "For example, if the subject of an assertion is a nullable type (in other words it's an  Assertion T? ) the assertion methods  isNull()  and  isNotNull()  are available.\nThe return type of  isNotNull()  is  Assertion T  because we now  know  the subject is not null.\nYou will find IDE code-completion will no longer offer the  isNull()  and  isNotNull()  assertion methods.", 
            "title": "Nullable subjects"
        }, 
        {
            "location": "/user-guide/flow-typing/#narrowing-assertions", 
            "text": "Another example is making assertions about a subject's specific runtime type, or \"narrowing\".  For example:  val subject: Map String, Any  = mapOf( count  to 1,  name  to  Rob )\nexpect(subject.get( count ))\n  .isA Number ()\n  .isGreaterThan(0)\n\nexpect(subject.get( name ))\n  .isA String ()\n  .hasLength(3)  The return type of the subject map's  get()  method is  Any  but using the narrowing assertion  isA T ()  we can both assert the type of the value and, because the compiler now knows it is dealing with an  Assertion String  or an  Assertion Number , we can use more specialized assertion methods that are only available for those subject types.  Without the  isA T ()  assertion the code would not compile:  val subject: Map String, Any  = mapOf( count  to 1,  name  to  Rob )\nexpect(subject.get( count ))\n  .isGreaterThan(0) \n  // isGreaterThan does not exist on Assertion Any \n\nexpect(subject.get( name ))\n  .hasLength(3) \n  // hasLength does not exist on Assertion Any   This mechanism means that IDE code-completion is optimally helpful as only assertion methods that are appropriate to the subject type will be suggested.", 
            "title": "Narrowing assertions"
        }, 
        {
            "location": "/user-guide/mapping/", 
            "text": "Mapping Over Assertion Subjects\n\n\nAlthough you can obviously write assertions for the properties of an object with code like this:\n\n\nexpect(map.size).isEqualTo(1)\nexpect(list.first()).isEqualTo(\ncovfefe\n)\nexpect(person.name).isEqualTo(\nZiggy\n)\n\n\n\n\nSometimes it's useful to be able to transform an assertion on a subject to an assertion on a property of that subject, or the result of a method call.\nStrikt allows for this using the \nAssertion\nT\n.map\n method.  \n\n\nMapping with lambdas\n\n\nThe method takes a lambda whose receiver is the current subject and returns an \nAssertion\nR\n where \nR\n is whatever the lambda returns.\n\n\nThis is sometimes useful for making assertions about the properties of an object or the values returned by methods, particularly if you want to use a block-style assertion to validate multiple object properties.\n\n\nval subject = Person(name = \nDavid\n, birthDate = LocalDate.of(1947, 1, 8))\nexpect(subject) {\n  map { name }.isEqualTo(\nDavid\n)\n  map { birthDate }.map { year }.isEqualTo(1947)\n}\n\n\n\n\nMapping with property or method references\n\n\nIf you use a Kotlin property or Java method reference as the lambda passed to \nmap\n, Strikt will automatically derive the property name and use it as the subject description on the returned assertion. \nThis is useful for generating good quality assertion output with minimal effort.\n\n\nFor example, if the previous example fails it will format the error message like this:\n\n\n\u25bc Person[name: Ziggy, birthDate: 1972-06-16] \n  \u25bc Ziggy \n    \u2717 is equal to David\n  \u25bc 1972-06-16 \n    \u25bc 1972\n      \u2717 is equal to 1947\n\n\n\n\nUsing property references the output is more useful.\n\n\nval subject = Person(name = \nDavid\n, birthDate = LocalDate.of(1947, 1, 8))\nexpect(subject) {\n  map(Person::name).isEqualTo(\nDavid\n)\n  map(Person::birthDate).map(LocalDate::getYear).isEqualTo(1947)\n}\n\n\n\n\n\u25bc Person[name: Ziggy, birthDate: 1972-06-16] \n  \u25bc .name Ziggy \n    \u2717 is equal to David\n  \u25bc .birthDate 1972-06-16\n    \u25bc .year 1972 \n      \u2717 is equal to 1947\n\n\n\n\nCreating re-usable mappings with extensions\n\n\nIf you find yourself frequently using \nmap\n for the same properties or methods, you should consider defining extension property or method to make things even easier.\nStrikt makes this easy.\n\n\nFor example:\n\n\nval Assertion\nPerson\n.name: Assertion\nString\n\n  get() = map(Person::name)\n\nval Assertion\nPerson\n.yearOfBirth: Assertion\nLocalDate\n\n  get() = map { dateOfBirth.year }\n\n\n\n\nYou can then write the earlier example as:\n\n\nval subject = Person(name = \nDavid\n, birthDate = LocalDate.of(1947, 1, 8))\nexpect(subject) {\n  name.isEqualTo(\nDavid\n)\n  yearOfBirth.isEqualTo(1947)\n}\n\n\n\n\nBuilt-in mappings\n\n\nStrikt has a number of built in mapping properties and functions such as \nAssertion\nList\nE\n.first()\n which returns an \nAssertion\nE\n whose subject is the first element of the list.", 
            "title": "Mapping Over Assertion Subjects"
        }, 
        {
            "location": "/user-guide/mapping/#mapping-over-assertion-subjects", 
            "text": "Although you can obviously write assertions for the properties of an object with code like this:  expect(map.size).isEqualTo(1)\nexpect(list.first()).isEqualTo( covfefe )\nexpect(person.name).isEqualTo( Ziggy )  Sometimes it's useful to be able to transform an assertion on a subject to an assertion on a property of that subject, or the result of a method call.\nStrikt allows for this using the  Assertion T .map  method.", 
            "title": "Mapping Over Assertion Subjects"
        }, 
        {
            "location": "/user-guide/mapping/#mapping-with-lambdas", 
            "text": "The method takes a lambda whose receiver is the current subject and returns an  Assertion R  where  R  is whatever the lambda returns.  This is sometimes useful for making assertions about the properties of an object or the values returned by methods, particularly if you want to use a block-style assertion to validate multiple object properties.  val subject = Person(name =  David , birthDate = LocalDate.of(1947, 1, 8))\nexpect(subject) {\n  map { name }.isEqualTo( David )\n  map { birthDate }.map { year }.isEqualTo(1947)\n}", 
            "title": "Mapping with lambdas"
        }, 
        {
            "location": "/user-guide/mapping/#mapping-with-property-or-method-references", 
            "text": "If you use a Kotlin property or Java method reference as the lambda passed to  map , Strikt will automatically derive the property name and use it as the subject description on the returned assertion. \nThis is useful for generating good quality assertion output with minimal effort.  For example, if the previous example fails it will format the error message like this:  \u25bc Person[name: Ziggy, birthDate: 1972-06-16] \n  \u25bc Ziggy \n    \u2717 is equal to David\n  \u25bc 1972-06-16 \n    \u25bc 1972\n      \u2717 is equal to 1947  Using property references the output is more useful.  val subject = Person(name =  David , birthDate = LocalDate.of(1947, 1, 8))\nexpect(subject) {\n  map(Person::name).isEqualTo( David )\n  map(Person::birthDate).map(LocalDate::getYear).isEqualTo(1947)\n}  \u25bc Person[name: Ziggy, birthDate: 1972-06-16] \n  \u25bc .name Ziggy \n    \u2717 is equal to David\n  \u25bc .birthDate 1972-06-16\n    \u25bc .year 1972 \n      \u2717 is equal to 1947", 
            "title": "Mapping with property or method references"
        }, 
        {
            "location": "/user-guide/mapping/#creating-re-usable-mappings-with-extensions", 
            "text": "If you find yourself frequently using  map  for the same properties or methods, you should consider defining extension property or method to make things even easier.\nStrikt makes this easy.  For example:  val Assertion Person .name: Assertion String \n  get() = map(Person::name)\n\nval Assertion Person .yearOfBirth: Assertion LocalDate \n  get() = map { dateOfBirth.year }  You can then write the earlier example as:  val subject = Person(name =  David , birthDate = LocalDate.of(1947, 1, 8))\nexpect(subject) {\n  name.isEqualTo( David )\n  yearOfBirth.isEqualTo(1947)\n}", 
            "title": "Creating re-usable mappings with extensions"
        }, 
        {
            "location": "/user-guide/mapping/#built-in-mappings", 
            "text": "Strikt has a number of built in mapping properties and functions such as  Assertion List E .first()  which returns an  Assertion E  whose subject is the first element of the list.", 
            "title": "Built-in mappings"
        }, 
        {
            "location": "/user-guide/common-patterns/", 
            "text": "Common Assertion Patterns\n\n\nThis section contains some common uses of Strikt's standard assertion library.\n\n\nAssertions on elements of a collection\n\n\nSome assertions on collections include sub-assertions applied to the elements of the collection.\nFor example, we can assert that \nall\n elements conform to a repeated assertion.\n\n\nval subject = setOf(\ncatflap\n, \nrubberplant\n, \nmarzipan\n)\nexpect(subject).all {\n  isLowerCase()\n  startsWith('c')\n}\n\n\n\n\nThis produces the output:\n\n\n\u25bc Expect that [catflap, rubberplant, marzipan] \n  \u2717 all elements match:\n    \u25bc \ncatflap\n\n      \u2713 starts with 'c'\n      \u2713 is lower case\n    \u25bc \nrubberplant\n \n      \u2717 starts with 'c'\n      \u2713 is lower case\n    \u25bc \nmarzipan\n\n      \u2717 starts with 'c'\n      \u2713 is lower case\n\n\n\n\nThe results are broken down by individual elements in the collection so it's easy to see which failed.\n\n\nAsserting exceptions are thrown\n\n\nTo assert that some code throws an exception you can use an assertion on a lambda \n() -\n Unit\n that performs the operation that should throw an exception and the \nthrows\nE\n assertion function.\nFor example:\n\n\nexpect { service.computeMeaning() }\n  .throws\nTooMuchFlaxException\n()\n\n\n\n\nThe \nthrows\nE\n function returns an \nAssertion\nE\n so you can chain assertions about the exception after it.\n\n\nThere is also a top level function \nthrows( () -\n Unit )\n that makes this even more concise.\n\n\nthrows\nTooMuchFlaxException\n { \n  service.computeMeaning() \n}", 
            "title": "Common Assertion Patterns"
        }, 
        {
            "location": "/user-guide/common-patterns/#common-assertion-patterns", 
            "text": "This section contains some common uses of Strikt's standard assertion library.", 
            "title": "Common Assertion Patterns"
        }, 
        {
            "location": "/user-guide/common-patterns/#assertions-on-elements-of-a-collection", 
            "text": "Some assertions on collections include sub-assertions applied to the elements of the collection.\nFor example, we can assert that  all  elements conform to a repeated assertion.  val subject = setOf( catflap ,  rubberplant ,  marzipan )\nexpect(subject).all {\n  isLowerCase()\n  startsWith('c')\n}  This produces the output:  \u25bc Expect that [catflap, rubberplant, marzipan] \n  \u2717 all elements match:\n    \u25bc  catflap \n      \u2713 starts with 'c'\n      \u2713 is lower case\n    \u25bc  rubberplant  \n      \u2717 starts with 'c'\n      \u2713 is lower case\n    \u25bc  marzipan \n      \u2717 starts with 'c'\n      \u2713 is lower case  The results are broken down by individual elements in the collection so it's easy to see which failed.", 
            "title": "Assertions on elements of a collection"
        }, 
        {
            "location": "/user-guide/common-patterns/#asserting-exceptions-are-thrown", 
            "text": "To assert that some code throws an exception you can use an assertion on a lambda  () -  Unit  that performs the operation that should throw an exception and the  throws E  assertion function.\nFor example:  expect { service.computeMeaning() }\n  .throws TooMuchFlaxException ()  The  throws E  function returns an  Assertion E  so you can chain assertions about the exception after it.  There is also a top level function  throws( () -  Unit )  that makes this even more concise.  throws TooMuchFlaxException  { \n  service.computeMeaning() \n}", 
            "title": "Asserting exceptions are thrown"
        }, 
        {
            "location": "/user-guide/custom-assertions/", 
            "text": "Custom Assertions\n\n\nOne of the aims of Strikt is that implementing your own assertions is \nreally, really\n easy.\nAssertion functions are \nextension functions\n on the interface \nAssertion\nT\n.\n\n\nAtomic assertions\n\n\n\"Atomic\" assertions produce a single message on failure.\nThey call \nassert\n passing a lambda with the assertion logic that calls \npass()\n or \nfail()\n.\n\n\nThe standard assertions \nisNull\n, \nisEqualTo\n, \nisA\nT\n and many others are simple assertions implemented just like this.\n\n\nLet's imagine we're implementing an assertion function for \njava.time.LocalDate\n that tests if the represented date is a leap day.\n\n\nfun Assertion\nLocalDate\n.isStTibsDay(): Assertion\nLocalDate\n =\n  assert(\nis St. Tib's Day\n) { \n    when (MonthDay.from(subject)) {\n      MonthDay.of(2, 29) -\n pass()\n      else               -\n fail()\n    }\n  }\n\n\n\n\nBreaking this down: \n\n\n\n\nWe declare the assertion function applies only to \nAssertion\nLocalDate\n.\n\n\nNote that the function also returns \nAssertion\nLocalDate\n so we can include this assertion as part of a chain.\n\n\nWe call \nassert\n passing a description of the assertion and a lambda with the assertion logic.\n\n\nIf \nsubject\n is the value we want we call \npass()\n otherwise we call \nfail()\n\n\n\n\nIf this assertion fails it will produce a message like:\n\n\n\u25bc Expect that 2018-05-01\n  \u2717 is St. Tib's Day \n\n\n\n\n\n\nInfo\n\n\nThe method \nassert\n accepts a description for the assertion being made and a lambda function \nAssertionContext\nT\n.() -\n Unit\n.\nThat \nAssertionContext\nT\n receiver provides the lambda everything it needs to access the \nsubject\n of the assertion and report the result via the \npass()\n or \nfail()\n method.\n\n\n\n\nDescribing the \"actual\" value\n\n\nFor assertions that perform a comparison between actual and expected values it is usually helpful to describe the value that was incorrect.\nThat way any assertion failure message will be more helpful.\n\n\nIn order to do this, Strikt provides an overridden version of \nfail()\n that accepts a message string and the actual value found.\nThe message string should contain a format placeholder for the value.\n\n\nfun Assertion\nLocalDate\n.isStTibsDay(): Assertion\nLocalDate\n =\n  assert(\nis St. Tib's Day\n) { \n    when (MonthDay.from(subject)) {\n      MonthDay.of(2, 29) -\n pass()\n      else               -\n fail(\nin fact it is %s\n, subject)\n    }\n  }\n\n\n\n\nNow if the assertion fails there is a little more detail.\n\n\n\u25bc Expect that 2018-05-01\n  \u2717 is St. Tib's Day\n    \u2022 in fact it is 2018-05-01\n\n\n\n\nIn this case that's not terribly helpful but when dealing with properties, method return values, or the like it can save a lot of effort in identifying the precise cause of an error.\n\n\nSimple atomic assertions with boolean expressions\n\n\nFor the simplest assertion functions, instead of using \nassert\n and calling \npass\n or \nfail\n, you can use \npassesIf\n with a lambda whose receiver is the assertion subject that returns a boolean.\n\n\nWe can re-implement the example above like this:\n\n\nfun Assertion\nLocalDate\n.isStTibsDay(): Assertion\nLocalDate\n =\n  passesIf(\nis St. Tib's Day\n) { \n    MonthDay.from(this) == MonthDay.of(2, 29)\n  }\n\n\n\n\nYou should not use this form when you want to provide a meaningful description of the actual value but for simple assertions it's slightly less verbose.\n\n\nComposed assertions\n\n\nFor more complex assertion implementations you can \"nest\" sub-assertions inside your overall assertion.\nComposed assertions' results are reported under the overall result which is useful for providing detailed diagnostic information in case of a failure.\n\n\nComposed assertions are useful for things like:\n\n\n\n\napplying assertions to multiple properties of an object, for example for a field-by-field comparison.\n\n\napplying assertions to all elements of a collection or entries in a map, reporting on individual elements.\n\n\n\n\nImagine we're creating an assertion function that tests fails if any element of a collection is \nnull\n.\n\n\nfun \nT: Iterable\nE?\n, E\n Assertion\nT\n.containsNoNullElements(): Assertion\nT\n =\n  assert(\ndoes not contain any null elements\n) {\n    compose {\n      subject.forEach {\n        expect(it).isNotNull()\n      }\n    } results {\n      if (allPassed) pass() else fail()\n    }\n  }\n\n\n\n\nBreaking this down:\n\n\n\n\nWe declare the overall assertion function applies to an \nIterable\n of a nullable element type \nE\n.\n\n\nWe use the \nassert\n method to create the overall assertion with a description as usual.\n\n\nInside the block passed to \ncompose\n we make an assertion about each element of the subject.\n\n\nInside the results block we pass or fail the overall assertion depending on whether the nested assertions all passed.\n\n\n\n\nThe receiver of the block passed to \nresult\n has the properties \nallFailed\n, \nanyFailed\n, \nallPassed\n and \nanyPassed\n along with \npass()\n and \nfail()\n functions similar to those used in simple assertions.\n\n\nIf the assertion failed we'll see something like this:\n\n\n\u25bc Expect that [catflap, null, rubberplant, marzipan] \n  \u2717 does not contain any null elements: \n    \u25bc \ncatflap\n \n      \u2713 is not null\n    \u25bc null \n      \u2717 is not null  \n    \u25bc \nrubberplant\n \n      \u2713 is not null\n    \u25bc \nmarzipan\n \n      \u2713 is not null\n\n\n\n\nAs well as the overall assertion failure message we get a detailed breakdown allowing us to easily find exactly where the problem is.\n\n\nSeveral assertion functions in Strikt's standard assertions library use nested assertions.\nFor example, \nAssertion\nIterable\nE\n.all\n applies assertions to each element of an \nIterable\n then passes the overall assertion if (and only if) all those nested assertions passed (\nallPassed\n).\nOn the other hand \nAssertion\nIterable\nE\n.any\n applies assertions to the elements of an \nIterable\n but will pass the overall assertion if at least one of those nested assertions passed (\nanyPassed\n).\nThe \nAssertion\nIterable\nE\n.none\n assertion passes only if \nallFailed\n is true for its nested assertions!", 
            "title": "Custom Assertions"
        }, 
        {
            "location": "/user-guide/custom-assertions/#custom-assertions", 
            "text": "One of the aims of Strikt is that implementing your own assertions is  really, really  easy.\nAssertion functions are  extension functions  on the interface  Assertion T .", 
            "title": "Custom Assertions"
        }, 
        {
            "location": "/user-guide/custom-assertions/#atomic-assertions", 
            "text": "\"Atomic\" assertions produce a single message on failure.\nThey call  assert  passing a lambda with the assertion logic that calls  pass()  or  fail() .  The standard assertions  isNull ,  isEqualTo ,  isA T  and many others are simple assertions implemented just like this.  Let's imagine we're implementing an assertion function for  java.time.LocalDate  that tests if the represented date is a leap day.  fun Assertion LocalDate .isStTibsDay(): Assertion LocalDate  =\n  assert( is St. Tib's Day ) { \n    when (MonthDay.from(subject)) {\n      MonthDay.of(2, 29) -  pass()\n      else               -  fail()\n    }\n  }  Breaking this down:    We declare the assertion function applies only to  Assertion LocalDate .  Note that the function also returns  Assertion LocalDate  so we can include this assertion as part of a chain.  We call  assert  passing a description of the assertion and a lambda with the assertion logic.  If  subject  is the value we want we call  pass()  otherwise we call  fail()   If this assertion fails it will produce a message like:  \u25bc Expect that 2018-05-01\n  \u2717 is St. Tib's Day    Info  The method  assert  accepts a description for the assertion being made and a lambda function  AssertionContext T .() -  Unit .\nThat  AssertionContext T  receiver provides the lambda everything it needs to access the  subject  of the assertion and report the result via the  pass()  or  fail()  method.", 
            "title": "Atomic assertions"
        }, 
        {
            "location": "/user-guide/custom-assertions/#describing-the-actual-value", 
            "text": "For assertions that perform a comparison between actual and expected values it is usually helpful to describe the value that was incorrect.\nThat way any assertion failure message will be more helpful.  In order to do this, Strikt provides an overridden version of  fail()  that accepts a message string and the actual value found.\nThe message string should contain a format placeholder for the value.  fun Assertion LocalDate .isStTibsDay(): Assertion LocalDate  =\n  assert( is St. Tib's Day ) { \n    when (MonthDay.from(subject)) {\n      MonthDay.of(2, 29) -  pass()\n      else               -  fail( in fact it is %s , subject)\n    }\n  }  Now if the assertion fails there is a little more detail.  \u25bc Expect that 2018-05-01\n  \u2717 is St. Tib's Day\n    \u2022 in fact it is 2018-05-01  In this case that's not terribly helpful but when dealing with properties, method return values, or the like it can save a lot of effort in identifying the precise cause of an error.", 
            "title": "Describing the \"actual\" value"
        }, 
        {
            "location": "/user-guide/custom-assertions/#simple-atomic-assertions-with-boolean-expressions", 
            "text": "For the simplest assertion functions, instead of using  assert  and calling  pass  or  fail , you can use  passesIf  with a lambda whose receiver is the assertion subject that returns a boolean.  We can re-implement the example above like this:  fun Assertion LocalDate .isStTibsDay(): Assertion LocalDate  =\n  passesIf( is St. Tib's Day ) { \n    MonthDay.from(this) == MonthDay.of(2, 29)\n  }  You should not use this form when you want to provide a meaningful description of the actual value but for simple assertions it's slightly less verbose.", 
            "title": "Simple atomic assertions with boolean expressions"
        }, 
        {
            "location": "/user-guide/custom-assertions/#composed-assertions", 
            "text": "For more complex assertion implementations you can \"nest\" sub-assertions inside your overall assertion.\nComposed assertions' results are reported under the overall result which is useful for providing detailed diagnostic information in case of a failure.  Composed assertions are useful for things like:   applying assertions to multiple properties of an object, for example for a field-by-field comparison.  applying assertions to all elements of a collection or entries in a map, reporting on individual elements.   Imagine we're creating an assertion function that tests fails if any element of a collection is  null .  fun  T: Iterable E? , E  Assertion T .containsNoNullElements(): Assertion T  =\n  assert( does not contain any null elements ) {\n    compose {\n      subject.forEach {\n        expect(it).isNotNull()\n      }\n    } results {\n      if (allPassed) pass() else fail()\n    }\n  }  Breaking this down:   We declare the overall assertion function applies to an  Iterable  of a nullable element type  E .  We use the  assert  method to create the overall assertion with a description as usual.  Inside the block passed to  compose  we make an assertion about each element of the subject.  Inside the results block we pass or fail the overall assertion depending on whether the nested assertions all passed.   The receiver of the block passed to  result  has the properties  allFailed ,  anyFailed ,  allPassed  and  anyPassed  along with  pass()  and  fail()  functions similar to those used in simple assertions.  If the assertion failed we'll see something like this:  \u25bc Expect that [catflap, null, rubberplant, marzipan] \n  \u2717 does not contain any null elements: \n    \u25bc  catflap  \n      \u2713 is not null\n    \u25bc null \n      \u2717 is not null  \n    \u25bc  rubberplant  \n      \u2713 is not null\n    \u25bc  marzipan  \n      \u2713 is not null  As well as the overall assertion failure message we get a detailed breakdown allowing us to easily find exactly where the problem is.  Several assertion functions in Strikt's standard assertions library use nested assertions.\nFor example,  Assertion Iterable E .all  applies assertions to each element of an  Iterable  then passes the overall assertion if (and only if) all those nested assertions passed ( allPassed ).\nOn the other hand  Assertion Iterable E .any  applies assertions to the elements of an  Iterable  but will pass the overall assertion if at least one of those nested assertions passed ( anyPassed ).\nThe  Assertion Iterable E .none  assertion passes only if  allFailed  is true for its nested assertions!", 
            "title": "Composed assertions"
        }, 
        {
            "location": "/about/", 
            "text": "About Strikt\n\n\nStrikt was written by \nRob Fletcher\n.\n\n\nLicense\n\n\nStrikt is licensed under the \nApache License v2.0\n.\n\n\nContributing\n\n\nSuggestions and contributions are welcome.\n\n\n\n\nIssues\n: You can discuss and raise issues on \nGitHub\n.\n\n\nSlack\n: Join the \n#strikt\n channel on the Kotlin Slack.", 
            "title": "About"
        }, 
        {
            "location": "/about/#about-strikt", 
            "text": "Strikt was written by  Rob Fletcher .", 
            "title": "About Strikt"
        }, 
        {
            "location": "/about/#license", 
            "text": "Strikt is licensed under the  Apache License v2.0 .", 
            "title": "License"
        }, 
        {
            "location": "/about/#contributing", 
            "text": "Suggestions and contributions are welcome.   Issues : You can discuss and raise issues on  GitHub .  Slack : Join the  #strikt  channel on the Kotlin Slack.", 
            "title": "Contributing"
        }
    ]
}